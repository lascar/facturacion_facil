#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Tests de comparaison de performance entre les versions originales et optimis√©es
"""

import time
import pytest
import sys
import os

# Ajouter le r√©pertoire racine au path
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from database.models import Factura, Stock, Producto
from database.optimized_models import OptimizedFactura, OptimizedStock, OptimizedProducto
from utils.performance_optimizer import performance_monitor, optimize_database_queries
from test.utils.test_database_manager import isolated_test_db


class TestPerformanceComparison:
    """Tests de comparaison de performance"""
    
    @pytest.fixture(autouse=True)
    def setup_performance_data(self):
        """Utiliser la base de donn√©es principale pour les tests de performance"""
        # Optimiser la base de donn√©es principale
        optimize_database_queries()

        print("\nüîß Utilisation de la base de donn√©es principale pour les tests...")

        # Compter les donn√©es existantes
        productos_count = len(Producto.get_all())
        facturas_count = len(Factura.get_all())

        print(f"   üìä Datos existentes: {productos_count} productos, {facturas_count} facturas")

        # Si nous n'avons pas assez de donn√©es, en cr√©er plus
        if productos_count < 20:
            print("   üîß Cr√©ant des donn√©es suppl√©mentaires...")
            for i in range(20 - productos_count):
                producto = Producto(
                    nombre=f"Producto Test {i:03d}",
                    referencia=f"REF{i:03d}",
                    precio=10.0 + (i % 50),
                    categoria=f"Categoria {i % 10}",
                    descripcion=f"Descripci√≥n del producto {i}",
                    iva_recomendado=21.0
                )
                producto.save()

        if facturas_count < 10:
            print("   üîß Cr√©ant des facturas suppl√©mentaires...")
            productos = Producto.get_all()
            for i in range(10 - facturas_count):
                factura = Factura(
                    numero_factura=f"PERF-{i:04d}",
                    fecha_factura=f"2024-{(i % 12) + 1:02d}-{(i % 28) + 1:02d}",
                    nombre_cliente=f"Cliente Performance {i}",
                    subtotal=100.0 + (i % 500),
                    total_iva=21.0 + (i % 100),
                    total_factura=121.0 + (i % 600),
                    modo_pago="efectivo" if i % 2 == 0 else "tarjeta"
                )
                factura.save()

                # Ajouter quelques items
                if productos:
                    for j in range(2):
                        producto_idx = (i * 2 + j) % len(productos)
                        factura.add_item(
                            producto_id=productos[producto_idx].id,
                            cantidad=1 + (j % 3),
                            precio_unitario=productos[producto_idx].precio,
                            iva_aplicado=21.0
                        )

                factura.calculate_totals()
                factura.save()

        final_productos = len(Producto.get_all())
        final_facturas = len(Factura.get_all())
        print(f"   ‚úÖ Datos finales: {final_productos} productos, {final_facturas} facturas")

        yield None
    
    def test_facturas_performance_comparison(self, setup_performance_data):
        """Comparer les performances de chargement des facturas"""
        print(f"\nüìä Test de performance: Chargement des facturas")
        print(f"=" * 60)
        
        # Test version originale
        print(f"\n1Ô∏è‚É£ Version originale (Factura.get_all)")
        start_time = time.time()
        facturas_original = Factura.get_all()
        original_time = time.time() - start_time
        
        print(f"   üìÑ Facturas cargadas: {len(facturas_original)}")
        print(f"   ‚è±Ô∏è  Tiempo: {original_time:.3f} segundos")
        
        # Compter les requ√™tes N+1 (approximation)
        total_items = sum(len(f.items) for f in facturas_original)
        estimated_queries_original = 1 + len(facturas_original)  # 1 pour facturas + 1 par factura pour items
        print(f"   üîç Items totales: {total_items}")
        print(f"   üóÉÔ∏è  Consultas estimadas: {estimated_queries_original}")
        
        # Test version optimis√©e
        print(f"\n2Ô∏è‚É£ Version optimis√©e (OptimizedFactura.get_all_optimized)")
        start_time = time.time()
        facturas_optimized = OptimizedFactura.get_all_optimized()
        optimized_time = time.time() - start_time
        
        print(f"   üìÑ Facturas cargadas: {len(facturas_optimized)}")
        print(f"   ‚è±Ô∏è  Tiempo: {optimized_time:.3f} segundos")
        
        total_items_opt = sum(len(f.items) for f in facturas_optimized)
        estimated_queries_optimized = 2  # 1 pour facturas + 1 pour tous les items
        print(f"   üîç Items totales: {total_items_opt}")
        print(f"   üóÉÔ∏è  Consultas estimadas: {estimated_queries_optimized}")
        
        # Test version r√©sum√©
        print(f"\n3Ô∏è‚É£ Version r√©sum√© (OptimizedFactura.get_summary_optimized)")
        start_time = time.time()
        facturas_summary = OptimizedFactura.get_summary_optimized()
        summary_time = time.time() - start_time
        
        print(f"   üìÑ Facturas (r√©sum√©): {len(facturas_summary)}")
        print(f"   ‚è±Ô∏è  Tiempo: {summary_time:.3f} segundos")
        print(f"   üóÉÔ∏è  Consultas estimadas: 1")
        
        # Calculs de performance
        print(f"\nüìà R√©sultats de performance:")
        print(f"   üöÄ Am√©lioration optimis√©e vs originale: {original_time / optimized_time:.1f}x plus rapide")
        print(f"   üöÄ Am√©lioration r√©sum√© vs originale: {original_time / summary_time:.1f}x plus rapide")
        print(f"   üìâ R√©duction de requ√™tes: {estimated_queries_original} ‚Üí {estimated_queries_optimized} ({((estimated_queries_original - estimated_queries_optimized) / estimated_queries_original * 100):.1f}% moins)")
        
        # V√©rifications de performance (pas de comparaison de nombres)
        assert len(facturas_original) > 0, "Aucune factura originale charg√©e"
        assert len(facturas_optimized) > 0, "Aucune factura optimis√©e charg√©e"
        assert len(facturas_summary) > 0, "Aucune factura r√©sum√© charg√©e"

        # Les performances doivent √™tre meilleures ou √©gales
        assert optimized_time <= original_time + 0.001, "Version optimis√©e plus lente"
        assert summary_time <= optimized_time + 0.001, "Version r√©sum√© plus lente"
        
        print(f"   ‚úÖ Toutes les v√©rifications pass√©es")
    
    def test_stock_performance_comparison(self, setup_performance_data):
        """Comparer les performances de chargement du stock"""
        print(f"\nüìä Test de performance: Chargement du stock")
        print(f"=" * 60)
        
        # Simuler le chargement original avec requ√™tes N+1
        print(f"\n1Ô∏è‚É£ Version originale simul√©e (avec N+1)")
        start_time = time.time()
        
        # Simuler Stock.get_all() + requ√™tes individuelles pour dates
        stock_basic = Stock.get_all()
        for row in stock_basic:
            producto_id = row[0]
            # Simuler la requ√™te individuelle pour fecha_actualizacion
            from database.database import db
            fecha_query = "SELECT fecha_actualizacion FROM stock WHERE producto_id=?"
            db.execute_query(fecha_query, (producto_id,))
        
        original_time = time.time() - start_time
        
        print(f"   üì¶ Productos en stock: {len(stock_basic)}")
        print(f"   ‚è±Ô∏è  Tiempo: {original_time:.3f} segundos")
        print(f"   üóÉÔ∏è  Consultas estimadas: {1 + len(stock_basic)}")
        
        # Test version optimis√©e
        print(f"\n2Ô∏è‚É£ Version optimis√©e (OptimizedStock.get_all_optimized)")
        start_time = time.time()
        stock_optimized = OptimizedStock.get_all_optimized()
        optimized_time = time.time() - start_time
        
        print(f"   üì¶ Productos en stock: {len(stock_optimized)}")
        print(f"   ‚è±Ô∏è  Tiempo: {optimized_time:.3f} segundos")
        print(f"   üóÉÔ∏è  Consultas estimadas: 1")
        
        # Calculs de performance
        print(f"\nüìà R√©sultats de performance:")
        print(f"   üöÄ Am√©lioration: {original_time / optimized_time:.1f}x plus rapide")
        print(f"   üìâ R√©duction de requ√™tes: {1 + len(stock_basic)} ‚Üí 1 ({len(stock_basic) / (1 + len(stock_basic)) * 100:.1f}% moins)")
        
        # V√©rifications de performance
        assert len(stock_basic) > 0, "Aucun stock de base charg√©"
        assert len(stock_optimized) > 0, "Aucun stock optimis√© charg√©"
        assert optimized_time <= original_time + 0.001, "Version optimis√©e plus lente"
        
        print(f"   ‚úÖ Toutes les v√©rifications pass√©es")
    
    def test_productos_with_stock_performance(self, setup_performance_data):
        """Comparer les performances de chargement des productos avec stock"""
        print(f"\nüìä Test de performance: Productos avec stock")
        print(f"=" * 60)
        
        # Version originale simul√©e
        print(f"\n1Ô∏è‚É£ Version originale simul√©e (avec N+1)")
        start_time = time.time()
        
        productos_original = Producto.get_all()
        for producto in productos_original:
            # Simuler la requ√™te individuelle pour le stock
            stock_actual = Stock.get_by_product(producto.id)
            producto._stock_actual = stock_actual
        
        original_time = time.time() - start_time
        
        print(f"   üõçÔ∏è  Productos cargados: {len(productos_original)}")
        print(f"   ‚è±Ô∏è  Tiempo: {original_time:.3f} segundos")
        print(f"   üóÉÔ∏è  Consultas estimadas: {1 + len(productos_original)}")
        
        # Version optimis√©e
        print(f"\n2Ô∏è‚É£ Version optimis√©e (OptimizedProducto.get_all_with_stock_optimized)")
        start_time = time.time()
        productos_optimized = OptimizedProducto.get_all_with_stock_optimized()
        optimized_time = time.time() - start_time
        
        print(f"   üõçÔ∏è  Productos cargados: {len(productos_optimized)}")
        print(f"   ‚è±Ô∏è  Tiempo: {optimized_time:.3f} segundos")
        print(f"   üóÉÔ∏è  Consultas estimadas: 1")
        
        # Version r√©sum√©
        print(f"\n3Ô∏è‚É£ Version r√©sum√© (OptimizedProducto.get_summary_optimized)")
        start_time = time.time()
        productos_summary = OptimizedProducto.get_summary_optimized()
        summary_time = time.time() - start_time
        
        print(f"   üõçÔ∏è  Productos (r√©sum√©): {len(productos_summary)}")
        print(f"   ‚è±Ô∏è  Tiempo: {summary_time:.3f} segundos")
        print(f"   üóÉÔ∏è  Consultas estimadas: 1")
        
        # Calculs de performance
        print(f"\nüìà R√©sultats de performance:")
        print(f"   üöÄ Am√©lioration optimis√©e vs originale: {original_time / optimized_time:.1f}x plus rapide")
        print(f"   üöÄ Am√©lioration r√©sum√© vs originale: {original_time / summary_time:.1f}x plus rapide")
        print(f"   üìâ R√©duction de requ√™tes: {1 + len(productos_original)} ‚Üí 1 ({len(productos_original) / (1 + len(productos_original)) * 100:.1f}% moins)")
        
        # V√©rifications de performance
        assert len(productos_original) > 0, "Aucun producto original charg√©"
        assert len(productos_optimized) > 0, "Aucun producto optimis√© charg√©"
        assert len(productos_summary) > 0, "Aucun producto r√©sum√© charg√©"
        assert optimized_time <= original_time + 0.001, "Version optimis√©e plus lente"
        
        print(f"   ‚úÖ Toutes les v√©rifications pass√©es")
    
    def test_cache_performance(self, setup_performance_data):
        """Tester les performances du cache"""
        print(f"\nüìä Test de performance: Cache")
        print(f"=" * 60)
        
        # Premier chargement (sans cache)
        print(f"\n1Ô∏è‚É£ Premier chargement (sans cache)")
        start_time = time.time()
        facturas1 = OptimizedFactura.get_summary_optimized()
        first_time = time.time() - start_time
        
        print(f"   üìÑ Facturas: {len(facturas1)}")
        print(f"   ‚è±Ô∏è  Tiempo: {first_time:.3f} segundos")
        
        # Deuxi√®me chargement (avec cache)
        print(f"\n2Ô∏è‚É£ Deuxi√®me chargement (avec cache)")
        start_time = time.time()
        facturas2 = OptimizedFactura.get_summary_optimized()
        cached_time = time.time() - start_time
        
        print(f"   üìÑ Facturas: {len(facturas2)}")
        print(f"   ‚è±Ô∏è  Tiempo: {cached_time:.3f} segundos")
        
        # Calculs de performance
        if cached_time > 0:
            improvement = first_time / cached_time
            print(f"\nüìà Am√©lioration avec cache: {improvement:.1f}x plus rapide")
        else:
            print(f"\nüìà Cache instantan√© (< 1ms)")
        
        # V√©rifications de cache
        assert len(facturas1) > 0, "Aucune factura dans le premier chargement"
        assert len(facturas2) > 0, "Aucune factura dans le deuxi√®me chargement"
        assert cached_time <= first_time + 0.001, "Cache pas plus rapide"
        
        print(f"   ‚úÖ Cache fonctionne correctement")
    
    def test_memory_usage_comparison(self, setup_performance_data):
        """Comparer l'utilisation m√©moire"""
        print(f"\nüìä Test de performance: Utilisation m√©moire")
        print(f"=" * 60)
        
        import psutil
        import os
        
        process = psutil.Process(os.getpid())
        
        # Mesure initiale
        initial_memory = process.memory_info().rss / 1024 / 1024  # MB
        print(f"\nüìä M√©moire initiale: {initial_memory:.1f} MB")
        
        # Chargement version originale
        print(f"\n1Ô∏è‚É£ Chargement version originale")
        memory_before_original = process.memory_info().rss / 1024 / 1024
        facturas_original = Factura.get_all()
        memory_after_original = process.memory_info().rss / 1024 / 1024
        
        original_memory_usage = memory_after_original - memory_before_original
        print(f"   üìÑ Facturas: {len(facturas_original)}")
        print(f"   üíæ M√©moire utilis√©e: {original_memory_usage:.1f} MB")
        
        # Nettoyer
        del facturas_original
        
        # Chargement version optimis√©e
        print(f"\n2Ô∏è‚É£ Chargement version optimis√©e")
        memory_before_optimized = process.memory_info().rss / 1024 / 1024
        facturas_optimized = OptimizedFactura.get_all_optimized()
        memory_after_optimized = process.memory_info().rss / 1024 / 1024
        
        optimized_memory_usage = memory_after_optimized - memory_before_optimized
        print(f"   üìÑ Facturas: {len(facturas_optimized)}")
        print(f"   üíæ M√©moire utilis√©e: {optimized_memory_usage:.1f} MB")
        
        # Chargement version r√©sum√©
        print(f"\n3Ô∏è‚É£ Chargement version r√©sum√©")
        memory_before_summary = process.memory_info().rss / 1024 / 1024
        facturas_summary = OptimizedFactura.get_summary_optimized()
        memory_after_summary = process.memory_info().rss / 1024 / 1024
        
        summary_memory_usage = memory_after_summary - memory_before_summary
        print(f"   üìÑ Facturas: {len(facturas_summary)}")
        print(f"   üíæ M√©moire utilis√©e: {summary_memory_usage:.1f} MB")
        
        # Comparaisons
        print(f"\nüìà Comparaison m√©moire:")
        if optimized_memory_usage > 0:
            print(f"   üîÑ Optimis√©e vs Originale: {original_memory_usage / optimized_memory_usage:.1f}x moins de m√©moire")
        if summary_memory_usage > 0:
            print(f"   üìã R√©sum√© vs Originale: {original_memory_usage / summary_memory_usage:.1f}x moins de m√©moire")
        
        print(f"   ‚úÖ Test m√©moire termin√©")


def run_performance_benchmark():
    """Ex√©cuter un benchmark complet de performance"""
    print(f"\nüöÄ BENCHMARK DE PERFORMANCE COMPLET")
    print(f"=" * 80)
    
    # Ex√©cuter les tests
    pytest.main([__file__, "-v", "-s", "--tb=short"])
    
    # Afficher les statistiques du moniteur
    print(f"\nüìä STATISTIQUES DE PERFORMANCE GLOBALES")
    print(f"=" * 80)
    performance_monitor.print_stats()


if __name__ == "__main__":
    run_performance_benchmark()
